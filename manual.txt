================================================================================
                    ТЕХНИЧЕСКОЕ РУКОВОДСТВО ИГРЫ CHAUPAR
                        Полное описание алгоритма и кода
================================================================================

СОДЕРЖАНИЕ:
1. АРХИТЕКТУРА И ОБЩИЙ ОБЗОР
2. КЛЮЧЕВЫЕ КОНСТАНТЫ И СТРУКТУРЫ ДАННЫХ
3. АЛГОРИТМ ИГРОВОГО ПРОЦЕССА
4. КАТАЛОГ ФУНКЦИЙ
5. СПЕЦИАЛЬНЫЕ МЕХАНИКИ
6. ТЕХНИЧЕСКАЯ РЕАЛИЗАЦИЯ

================================================================================
1. АРХИТЕКТУРА И ОБЩИЙ ОБЗОР
================================================================================

ОБЩАЯ СТРУКТУРА:
- Ванильная HTML/CSS/JavaScript реализация без внешних зависимостей
- Одностраничное приложение в файле index.html (~3400 строк)
- Интеграция с Supabase для многопользовательской игры
- Адаптивный дизайн для десктоп и мобильных устройств

ИГРОВОЕ ПОЛЕ:
- Координатная система: 15x15 сетка A1-O15 (A-O столбцы, 1-15 строки)
- 70+ игровых ячеек в массиве BOARD_CELLS
- Абсолютное позиционирование через coordToPosition() и positionToCoord()
- Динамическое создание DOM элементов для ячеек и фишек

ФАЗЫ ИГРЫ (gamePhase):
- 'setup': Начальная настройка, выбор количества игроков
- 'order-determination': Определение порядка ходов (разыгрывается кубиками)
- 'playing': Основная игра с поочередными ходами

ИГРОКИ:
- Поддержка 2-4 игроков
- currentPlayer: текущий активный игрок (1-4)
- playersOrder: массив порядка ходов после розыгрыша
- playerColors: массив цветов ['Красный', 'Желтый', 'Зеленый', 'Фиолетовый']

================================================================================
2. КЛЮЧЕВЫЕ КОНСТАНТЫ И СТРУКТУРЫ ДАННЫХ
================================================================================

БАЗОВЫЕ КОНСТАНТЫ:

BOARD_CELLS = [
    "G1", "H1", "I1", "F2", "G2", "H2", "I2", ...
]
// Массив всех игровых ячеек основного поля (70+ ячеек)

START_ZONES = {
    1: ["M1", "N1", "O1", "M2", "N2", "O2"],     // Красный
    2: ["A14", "B14", "C14", "A15", "B15", "C15"], // Желтый
    3: ["N13", "O13", "N14", "O14", "N15", "O15"], // Зеленый
    4: ["A1", "B1", "A2", "B2", "A3", "B3"]       // Фиолетовый
}
// Стартовые зоны для размещения фишек в начале игры

WAITING_ZONES = {
    1: ["K1", "K2", "K3", "K4"],     // Красный - зона ожидания
    2: ["E12", "E13", "E14", "E15"], // Желтый
    3: ["L11", "M11", "N11", "O11"], // Зеленый
    4: ["A5", "B5", "C5", "D5"]      // Фиолетовый
}
// Промежуточные зоны между стартом и основным полем

ENTRY_CELLS = {
    1: 'I1',   // Красный - точка входа на основное поле
    2: 'G15',  // Желтый
    3: 'O9',   // Зеленый
    4: 'A7'    // Фиолетовый
}

СПЕЦИАЛЬНЫЕ ЯЧЕЙКИ:

TEMPLE_COORDS = ['K6', 'J11', 'E10', 'F5']
// Храмы - защищенные ячейки, фишки нельзя сбивать

JAIL_COORDS = ['N6', 'J14', 'B10', 'F2']
// Тюрьмы - для выхода нужна 6 на кубике

TELEPORT_COORDS = {
    1: 'K7',   // Красный телепорт
    2: 'E9',   // Желтый телепорт
    3: 'J7',   // Зеленый телепорт
    4: 'E7'    // Фиолетовый телепорт
}

ПУТИ ДВИЖЕНИЯ:

PLAYER_PATHS = {
    1: ['I1', 'I2', 'I3', 'I4', 'I5', 'I6', 'I7', 'J7', 'K7', ...],  // Красный путь
    2: ['G15', 'G14', 'G13', 'G12', 'G11', 'G10', 'G9', ...],        // Желтый путь
    3: ['O9', 'N9', 'M9', 'L9', 'K9', 'J9', 'I9', ...],             // Зеленый путь
    4: ['A7', 'B7', 'C7', 'D7', 'E7', 'F7', 'G7', ...]              // Фиолетовый путь
}
// Определяют маршрут движения фишек каждого игрока по часовой стрелке

АВТОМАТИЧЕСКИЕ ПЕРЕМЕЩЕНИЯ:

SPECIAL_MOVES = {
    'K7': 'K6',   // Автоперемещение с K7 на K6
    'N7': 'N6',   // и т.д.
    'E7': 'E10',
    'F7': 'F5'
}
// Ячейки, которые автоматически перемещают фишку на соседнюю

ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ СОСТОЯНИЯ:

let currentPlayer = 1;                    // Текущий игрок (1-4)
let gamePhase = 'setup';                  // Фаза игры
let currentTurnNumber = 1;                // Номер хода
let selectedPiece = null;                 // Выделенная фишка
let lastDiceRoll = [0, 0];              // Последний бросок кубиков
let diceUsed = [false, false];          // Какие кубики использованы
let consecutiveDoubles = 0;              // Счетчик дублей подряд
let pieces = {};                         // Объект всех фишек по игрокам
let gameBoard = {};                      // Состояние игрового поля
let playersOrder = [];                   // Порядок ходов игроков
let currentGameId = null;                // ID текущей игры для синхронизации

================================================================================
3. АЛГОРИТМ ИГРОВОГО ПРОЦЕССА
================================================================================

3.1 ИНИЦИАЛИЗАЦИЯ ИГРЫ:

startGame():
1. Создание игрового поля (createBoard())
2. Размещение специальных элементов (createTemplesAndJails(), createTeleportIcons())
3. Создание фишек в стартовых зонах (createPieces())
4. Переход в фазу определения очередности (gamePhase = 'order-determination')
5. Генерация уникального ID игры для многопользовательского режима

3.2 ОПРЕДЕЛЕНИЕ ПОРЯДКА ХОДОВ:

handleOrderDetermination():
1. Каждый игрок бросает кубики (rollPlayerDice())
2. Результаты сохраняются с меткой isFirstMoveWinner = true
3. Игроки сортируются по убыванию суммы кубиков
4. Формируется массив playersOrder
5. Переход в фазу игры (gamePhase = 'playing')

3.3 ОСНОВНОЙ ЦИКЛ ИГРЫ:

СТРУКТУРА ХОДА:
1. Активация кубиков текущего игрока (updatePlayerDiceStates())
2. Бросок кубиков (rollPlayerDice())
3. Анализ возможных ходов (analyzePossibleMoves())
4. Ожидание действия игрока или автопропуск
5. Выполнение хода (performMove())
6. Проверка завершения хода (checkTurnCompletion())
7. Переход к следующему игроку (nextPlayer()) или дополнительный бросок

ДЕТАЛЬНЫЙ АЛГОРИТМ ХОДА:

rollPlayerDice():
- Генерация случайных значений (1-6)
- Анимация кубиков с задержкой
- Обновление lastDiceRoll = [dice1, dice2]
- Сброс diceUsed = [false, false]
- Вызов handleGamePlay()

handleGamePlay():
- Обработка дублей (1:1, 6:6 дают доп. броски)
- Анализ возможных ходов (analyzePossibleMoves())
- Проверка автопропуска (checkNoValidMoves())
- Активация UI для взаимодействия

performMove(piece, targetCoord):
- Валидация хода через calculatePossibleMoves() и filterMovesWithObstacles()
- Обработка коллизий и захватов фишек
- Физическое перемещение (movePiece())
- Обновление состояния (diceUsed, gameBoard)
- Проверка завершения хода (checkTurnCompletion())

checkTurnCompletion():
- Проверка использования всех кубиков
- Обработка дублей (до 3 подряд)
- Автопропуск при отсутствии ходов
- Переход хода (nextPlayer())

================================================================================
4. КАТАЛОГ ФУНКЦИЙ
================================================================================

4.1 ОСНОВНЫЕ ФУНКЦИИ УПРАВЛЕНИЯ ИГРОЙ:

startGame()
- Назначение: Инициализация новой игры
- Вызывает: createBoard(), createPieces(), createTemplesAndJails()
- Устанавливает: gamePhase = 'order-determination'

nextPlayer()
- Назначение: Переход хода к следующему игроку
- Обновляет: currentPlayer, currentTurnNumber
- Сбрасывает: rollCount, consecutiveDoubles, diceUsed
- Вызывает: updatePlayerDiceStates(), autoSaveGame()

handleGamePlay()
- Назначение: Центральная логика обработки игрового хода
- Анализирует: возможные ходы, дубли, автопропуск
- Вызывает: analyzePossibleMoves(), checkNoValidMoves()

checkTurnCompletion()
- Назначение: Проверка завершения хода игрока
- Проверяет: использование кубиков, наличие дублей
- Решает: дополнительный бросок или переход хода

4.2 ФУНКЦИИ ДВИЖЕНИЯ И ПОЗИЦИОНИРОВАНИЯ:

coordToPosition(coord)
- Назначение: Преобразование координат в пиксели
- Входы: строка координат (например, "I4")
- Возвращает: {x, y} позиция на экране
- Особенности: адаптивные размеры для мобильных устройств

positionToCoord(x, y)
- Назначение: Обратное преобразование пикселей в координаты
- Входы: пиксельные координаты
- Возвращает: строка координат или null

getCurrentPosition(piece)
- Назначение: Получение текущей позиции фишки
- Метод: Анализ CSS transform или data-атрибутов
- Возвращает: строка координат

movePiece(piece, targetCoord)
- Назначение: Физическое перемещение фишки
- Действия: Обновление CSS позиции, data-атрибутов
- Обработка: Анимации перемещения

4.3 ФУНКЦИИ РАСЧЕТА ХОДОВ:

calculatePossibleMoves(piece, steps, dice1, dice2)
- Назначение: Расчет всех теоретически возможных ходов
- Входы: фишка, макс. шаги, значения кубиков
- Логика по типу позиции:
  * start: нужна 1 для выхода в зону ожидания
  * waiting: любое значение для выхода на поле
  * board: движение по PLAYER_PATHS
- Возвращает: массив {coord, steps}

filterMovesWithObstacles(possibleMoves, piece, dice1, dice2)
- Назначение: Фильтрация ходов с учетом препятствий
- Проверяет: коллизии со своими/чужими фишками
- Правила захвата: можно сбить чужую фишку точным значением кубика
- Возвращает: массив валидных ходов

analyzePossibleMoves(dice1, dice2)
- Назначение: Анализ всех ходов текущего игрока
- Генерирует: текстовое описание доступных ходов
- Используется: для отображения в UI

checkNoValidMoves(dice1, dice2)
- Назначение: Проверка наличия возможных ходов
- Перебирает: все фишки игрока
- Учитывает: особые условия (тюрьма, стартовые зоны)
- Возвращает: true если ходов нет (для автопропуска)

4.4 ФУНКЦИИ ВЗАИМОДЕЙСТВИЯ:

handlePieceClick(piece)
- Назначение: Обработка кликов по фишкам
- Умная логика:
  * Клик по своей фишке = выделение/снятие выделения
  * Клик по чужой с выделенной своей = попытка захвата
  * Клик по чужой без выделенной = сообщение об ошибке

handleCellClick(coord)
- Назначение: Обработка кликов по ячейкам поля
- Действие: Попытка хода выделенной фишки на ячейку
- Вызывает: performMove() при наличии selectedPiece

showMoveHints(piece)
- Назначение: Отображение подсказок возможных ходов
- Создает: числовые маркеры на доступных ячейках
- Фильтрация: только для доступных значений кубиков
- Очистка: clearMoveHints()

4.5 ФУНКЦИИ РАБОТЫ С КУБИКАМИ:

rollPlayerDice()
- Назначение: Бросок кубиков для текущего игрока
- Генерация: Math.random() от 1 до 6
- Анимация: Поэтапная смена граней кубиков
- Результат: Обновление lastDiceRoll, вызов handleGamePlay()

handlePlayerDiceClick(player)
- Назначение: Обработка кликов по кубикам игрока
- Проверки: Активность игрока, фаза игры
- Действие: Вызов rollPlayerDice()

updatePlayerDiceStates()
- Назначение: Активация/деактивация кубиков игроков
- Логика: Активен только currentPlayer
- Визуал: Изменение прозрачности неактивных кубиков

isDouble(dice1, dice2)
- Назначение: Проверка на дубль
- Особенность: Только 1:1 и 6:6 считаются дублями для доп. бросков

4.6 ФУНКЦИИ СОЗДАНИЯ ЭЛЕМЕНТОВ:

createBoard()
- Назначение: Создание игрового поля
- Создает: DOM элементы для всех ячеек BOARD_CELLS
- Добавляет: обработчики событий, CSS классы
- Вызывает: createDirectionArrows() для стрелок направления

createPieces()
- Назначение: Создание фишек всех игроков
- Размещение: В стартовых зонах (START_ZONES)
- Обработчики: Drag&drop, клики, touch события
- Структура: pieces[player] = [{element, id}, ...]

createTemplesAndJails()
- Назначение: Размещение храмов и тюрем на поле
- Элементы: SVG иконки с tooltip подсказками
- События: mouseenter/mouseleave для показа описания

createTeleportIcons()
- Назначение: Создание иконок телепортов
- Цвета: Соответствуют цветам игроков
- Tooltip: Описание правил телепортации

4.7 ФУНКЦИИ МНОГОПОЛЬЗОВАТЕЛЬСКОЙ ИГРЫ:

autoSaveGame()
- Назначение: Автосохранение состояния игры
- Данные: Полная сериализация через serializeGameState()
- Отправка: В Supabase для синхронизации
- Trigger: После каждого значимого изменения

loadGame(gameId)
- Назначение: Загрузка сохраненной игры
- Источник: Supabase по ID игры
- Восстановление: Через deserializeGameState()
- Обязательно: Вызов updatePlayerDiceStates() после загрузки

serializeGameState()
- Назначение: Сериализация состояния в JSON
- Включает: позиции фишек, currentPlayer, gamePhase, кубики
- Исключает: DOM элементы, временные переменные

deserializeGameState(data)
- Назначение: Восстановление состояния из JSON
- Воссоздает: позиции фишек, игровые переменные
- Флаг: isRestoringState = true для предотвращения циклов

4.8 ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ:

updateGameMessage(text)
- Назначение: Обновление игрового сообщения для игрока
- Отображение: В game-message контейнере
- Форматирование: Поддержка многострочного текста

updatePlayerDisplay()
- Назначение: Обновление отображения текущего игрока
- Элементы: Цвет, имя игрока в UI

getPiecePosition(piece)
- Назначение: Определение типа позиции фишки
- Возвращает: {type: 'start'|'waiting'|'board', coord: string}
- Используется: Для логики движения

isInSpecialZone(coord)
- Назначение: Проверка на специальную зону (храм/тюрьма)
- Входы: координата ячейки
- Возвращает: Boolean

findFreeStartPosition(player)
- Назначение: Поиск свободной ячейки в стартовой зоне
- Используется: При сбитии фишки противника
- Возвращает: координата или null

================================================================================
5. СПЕЦИАЛЬНЫЕ МЕХАНИКИ
================================================================================

5.1 ПРАВИЛА ДВИЖЕНИЯ ИЗ СТАРТОВЫХ ЗОН:

ВЫХОД ИЗ START_ZONES:
- Требование: Обязательно значение 1 на одном из кубиков
- Назначение: Зона ожидания (WAITING_ZONES)
- Комбо-ходы: 1 для выхода + остаток для движения по полю
  Пример: При 1 и 5 фишка может пойти из M1 → K1 (зона ожидания)
          ИЛИ M1 → I5 (комбо-ход: выход + 4 шага по полю)

ВЫХОД ИЗ WAITING_ZONES:
- Требование: Любое значение кубиков
- Назначение: Основное поле через ENTRY_CELLS
- Расчет: targetIndex = entryIndex + steps - 1

5.2 ПРАВИЛА ТЮРЕМ:

ПОПАДАНИЕ В ТЮРЬМУ:
- Автоматическое при попадании на JAIL_COORDS
- Фишка защищена от сбивания

ВЫХОД ИЗ ТЮРЬМЫ:
- Требование: Обязательно 6 на одном из кубиков
- 6 тратится на освобождение
- Второй кубик определяет дистанцию движения
- Специальная обработка в showMoveHints() и calculatePossibleMoves()

5.3 СИСТЕМА ТЕЛЕПОРТАЦИИ:

АКТИВАЦИЯ ТЕЛЕПОРТА:
- Фишка должна находиться в своем телепорте (TELEPORT_COORDS)
- Должен пройти минимум 1 ход с момента попадания в телепорт
- Отслеживание через piecesTeleportHistory[pieceId] = turnNumber

ПРАВИЛА ТЕЛЕПОРТАЦИИ:
- На 1 кубика: следующий игрок по часовой стрелке
- На 3 кубика: игрок напротив
- На 6 кубика: предыдущий игрок против часовой
- Возможны комбинированные телепорт-ходы

РЕАЛИЗАЦИЯ:
calculateTeleportMoves(piece, dice1, dice2):
- Проверка доступности телепортации
- Расчет целевого телепорта по TELEPORT_MAPPINGS
- Проверка препятствий в целевом телепорте
- Расчет дальнейшего движения после телепортации

5.4 ПРАВИЛА ЗАХВАТА ФИШЕК:

УСЛОВИЯ ЗАХВАТА:
- Чужая фишка находится точно на конечной позиции хода
- Ход должен соответствовать точному значению одного из кубиков
- НЕ сумме кубиков (исправлено в последних версиях)

ИСКЛЮЧЕНИЯ:
- Фишки в храмах (TEMPLE_COORDS) защищены от захвата
- Фишки в тюрьмах (JAIL_COORDS) защищены от захвата
- Фишки в зонах ожидания не блокируют проход

РЕАЛИЗАЦИЯ В filterMovesWithObstacles():
```javascript
if (obstacleSteps === move.steps) {
    // Чужая фишка на конечной позиции - проверяем правила захвата
    if (!individualDiceValues.includes(move.steps)) {
        canMakeMove = false; // Нельзя захватить - не точное значение кубика
    }
}
```

5.5 СИСТЕМА ДУБЛЕЙ:

ОПРЕДЕЛЕНИЕ ДУБЛЕЙ:
- isDouble(dice1, dice2): только 1:1 и 6:6
- Остальные пары (2:2, 3:3, 4:4, 5:5) НЕ считаются дублями

ЛОГИКА ДУБЛЕЙ:
- Дают право на дополнительный бросок (до 3 раз подряд)
- Счетчик: consecutiveDoubles
- Приоритет над автопропуском: дубль дает бросок даже при отсутствии ходов
- Сброс при передаче хода другому игроку

5.6 АВТОПРОПУСК ХОДОВ:

УСЛОВИЯ АВТОПРОПУСКА:
- checkNoValidMoves() возвращает true
- НЕ дубль или исчерпан лимит дублей
- НЕ розыгрыш очередности

ПРОЦЕСС:
1. Анализ всех фишек игрока
2. Проверка специальных условий (тюрьма, стартовые зоны)
3. Расчет возможных ходов с учетом препятствий
4. Задержка 3 секунды + автоматический nextPlayer()

5.7 СПЕЦИАЛЬНЫЕ ПОЛЯ И АВТОПЕРЕМЕЩЕНИЯ:

SPECIAL_MOVES:
- Определенные ячейки автоматически перемещают фишку
- Пример: K7 → K6, E7 → E10
- Обработка в performMove() после основного хода
- Считается как обычный ход (расходует кубик)

5.8 КОМБИНИРОВАННЫЕ И СОСТАВНЫЕ ХОДЫ:

КОМБО-ХОДЫ ИЗ СТАРТОВЫХ ЗОН:
- 1 на выход + второй кубик на движение
- Прямое попадание на основное поле через ENTRY_CELLS
- Проверка препятствий на всем пути

ИСПОЛЬЗОВАНИЕ ДВУХ КУБИКОВ:
- Два отдельных хода на разные фишки
- Один ход на сумму кубиков (одна фишка)
- Отслеживание через diceUsed = [boolean, boolean]

================================================================================
6. ТЕХНИЧЕСКАЯ РЕАЛИЗАЦИЯ
================================================================================

6.1 СИСТЕМА СОБЫТИЙ И ИНТЕРФЕЙС:

ОБРАБОТКА КЛИКОВ:
- handlePieceClick(): Умная логика выделения/захвата
- handleCellClick(): Выполнение ходов
- handlePlayerDiceClick(): Броски кубиков

DRAG & DROP:
- handleTouchStart/Move/End(): Touch события для мобильных
- Поддержка жестов перетаскивания фишек
- Автоматическое определение целевой ячейки

ВИЗУАЛЬНЫЕ ПОДСКАЗКИ:
- showMoveHints(): Числовые маркеры возможных ходов
- Цветовая индикация: зеленый = обычный ход, красный = захват
- Анимации перемещения фишек

6.2 АДАПТИВНЫЙ ДИЗАЙН:

МЕДИА-ЗАПРОСЫ:
- @media (max-width: 768px) для мобильных устройств
- Адаптивные размеры кубиков, фишек, ячеек
- Изменение layout: вертикальное размещение на мобильных

ДИНАМИЧЕСКИЕ РАЗМЕРЫ:
- coordToPosition(): Расчет размеров на основе viewport
- Мобильные: cellSize = (boardSize-20) / 15
- Десктоп: cellSize = boardSize * 35 / 600

TOUCH ОПТИМИЗАЦИИ:
- Поддержка pinch-to-zoom
- Предотвращение случайных кликов
- Увеличенные области касания

6.3 МНОГОПОЛЬЗОВАТЕЛЬСКАЯ ИГРА:

SUPABASE ИНТЕГРАЦИЯ:
- Realtime subscriptions для live обновлений
- Автосохранение после каждого значимого действия
- Конфликт-резолюция через isRestoringState флаг

СИНХРОНИЗАЦИЯ:
- Полная сериализация состояния игры
- Двунаправленная синхронизация между клиентами
- Обработка потери соединения

ID ИГРЫ:
- Генерация уникальных ID формата CHPR-XXXXXXXX
- Возможность присоединения к существующей игре
- Восстановление прерванных сессий

6.4 УПРАВЛЕНИЕ СОСТОЯНИЕМ:

ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ:
- Централизованное хранение состояния игры
- Минимизация конфликтов через четкое разделение зон ответственности

ЖИЗНЕННЫЙ ЦИКЛ СОСТОЯНИЯ:
1. Инициализация (startGame)
2. Мутации (performMove, nextPlayer)
3. Сериализация (autoSaveGame)
4. Восстановление (deserializeGameState)

ПРЕДОТВРАЩЕНИЕ ЦИКЛОВ:
- isRestoringState флаг
- isUpdatingSelection для UI обновлений

6.5 ПРОИЗВОДИТЕЛЬНОСТЬ И ОПТИМИЗАЦИЯ:

DOM МАНИПУЛЯЦИИ:
- Минимизация перерисовок через CSS transform
- Использование документных фрагментов
- Переиспользование элементов

РАСЧЕТЫ:
- Кеширование результатов calculatePossibleMoves
- Ленивые вычисления для UI обновлений
- Оптимизированные алгоритмы поиска пути

ПАМЯТЬ:
- Очистка event listeners
- Контроль размера истории (diceLog, skippedTurns)
- Сборка мусора для временных объектов

6.6 ОТЛАДКА И ДИАГНОСТИКА:

ЛОГИРОВАНИЕ:
- Подробные console.log для ключевых операций
- Трассировка состояния игры
- Диагностика автопропуска и синхронизации

ВАЛИДАЦИЯ:
- Проверка корректности ходов на нескольких уровнях
- Валидация данных при сериализации/десериализации
- Обработка граничных случаев

TESTING HOOKS:
- Экспорт ключевых функций в глобальную область (для отладки)
- Возможность программного управления состоянием игры

7. ТЕХНИЧЕСКИЕ ДЕТАЛИ РЕАЛИЗАЦИИ

7.1 МОБИЛЬНАЯ ОПТИМИЗАЦИЯ:
- Touch события с поддержкой passive/non-passive обработки
- Viewport scaling и pinch-to-zoom функциональность
- Click-to-select как резервный механизм для сложных drag операций
- Анимированные подсказки ходов с CSS переходами
- Адаптивный дизайн с Media Queries
- Overflow защита для dice-panel и game-message контейнеров

7.2 АНАЛИТИКА:
- Yandex.Metrika интегрирована с ID `103866554` для домена chaupar.ru

7.3 МНОГОПОЛЬЗОВАТЕЛЬСКАЯ ИГРА:
- Supabase интеграция для сохранения/загрузки и real-time многопользователь
- Клиент инициализирован через CDN: `@supabase/supabase-js@2`
- Конфигурация загружается из `.env` файла с `VITE_SUPABASE_URL` и `VITE_SUPABASE_ANON_KEY`
- Сериализация/десериализация игрового состояния
- Генерация уникальных ID игры в формате `CHPR-XXXXXXXX`
- Real-time синхронизация между клиентами через Supabase Realtime каналы
- Автоматическое сохранение состояния игры и двунаправленная синхронизация

7.4 КРИТИЧЕСКИЕ ДЕТАЛИ РЕАЛИЗАЦИИ:
- `loadGame()` должна вызывать `updatePlayerDiceStates()` для активации кубиков после загрузки
- `restoreGameState()` создает конфликты синхронизации - предотвращается флагом `isRestoringState`
- Логика движения должна быть консистентной между всеми функциями расчета ходов
- `filterMovesWithObstacles()` ОБЯЗАТЕЛЬНО должна использоваться во всех функциях расчета ходов
- Подсказки ходов должны показываться только при selectedPiece === null
- Умная логика клика по фишке: свои - выделяются, чужие - съедаются при выделенной фишке

7.5 БЕЗОПАСНОСТЬ И ПРОИЗВОДИТЕЛЬНОСТЬ:
- Все действия с DOM выполняются через проверенные функции
- Supabase anon key безопасен для клиентской экспозиции (Row Level Security)
- Нет серверных секретов или приватных ключей в репозитории
- Аутентификация через Supabase security policies

8. СПЕЦИАЛЬНЫЕ МЕХАНИКИ

8.1 СИСТЕМА ЗАХВАТА:
```javascript
// Проверка возможности захвата
function canCapture(piece, targetCoord) {
    const occupyingPiece = getGameBoardPiece(targetCoord);
    if (!occupyingPiece) return false;

    const piecePlayer = parseInt(piece.dataset.player);
    const occupyingPlayer = parseInt(occupyingPiece.dataset.player);

    // Нельзя есть своих
    if (piecePlayer === occupyingPlayer) return false;

    // Защита в храмах и тюрьмах
    if (isTempleOrJailCell(targetCoord)) return false;

    return true;
}
```

8.2 ЛОГИКА ДУБЛЕЙ (ПАРНЫХ КУБИКОВ):
- Только 1:1 и 6:6 дают дополнительные броски
- Максимум 3 броска подряд, затем обычные правила
- Дубли имеют приоритет над авто-пропуском
- Комбинации 2:2, 3:3, 4:4, 5:5 считаются обычными ходами

8.3 ТЕЛЕПОРТАЦИЯ:
```javascript
// Система телепортации
const TELEPORT_PAIRS = {
    'K7': 'K6', 'N7': 'N6', 'G8': 'F8', 'H8': 'I8'
};

function handleTeleportation(piece, targetCoord) {
    if (TELEPORT_PAIRS[targetCoord]) {
        const teleportTarget = TELEPORT_PAIRS[targetCoord];
        movePieceToCoordinate(piece, teleportTarget);
        return true;
    }
    return false;
}
```

8.4 АВТО-ПРОПУСК ХОДОВ:
```javascript
// Механизм автоматического пропуска
function checkNoValidMoves() {
    if (gamePhase !== 'playing') return false;

    const playerPieces = getPlayerPieces(currentPlayer);
    let hasValidMoves = false;

    playerPieces.forEach(piece => {
        const moves = calculatePossibleMoves(piece);
        const filteredMoves = filterMovesWithObstacles(moves, piece);
        if (filteredMoves.length > 0) {
            hasValidMoves = true;
        }
    });

    return !hasValidMoves;
}
```

9. ОТЛАДКА И ДИАГНОСТИКА

9.1 СИСТЕМА ЛОГИРОВАНИЯ:
Игра использует консольное логирование с эмодзи для категоризации:
- 🎲 DICE: Операции с кубиками
- 🔄 SELECTION: Выделение фишек
- 🚀 TELEPORT: Телепортация
- 🏁 START_ZONE: Стартовые зоны
- 🔍 FILTER: Фильтрация ходов
- ✅/🚫 Успех/ошибка операций

9.2 ЧАСТЫЕ ПРОБЛЕМЫ:
1. **Подсказки не появляются**: Проверить selectedPiece === null
2. **Авто-пропуск не работает**: Проверить gamePhase === 'playing' и setTimeout
3. **Рассинхрон в мультиплеере**: Использовать isRestoringState флаг
4. **Фишки не двигаются**: Проверить updatePlayerDiceStates() после загрузки

9.3 ТЕСТИРОВАНИЕ ХОДОВ:
```javascript
// Отладочная функция для тестирования ходов
function debugMove(pieceId, targetCoord) {
    const piece = document.querySelector(`[data-id="${pieceId}"]`);
    const moves = calculatePossibleMoves(piece);
    const filtered = filterMovesWithObstacles(moves, piece);
    console.log('Possible moves:', moves);
    console.log('Filtered moves:', filtered);
    console.log('Can move to', targetCoord, ':',
        filtered.some(m => m.coord === targetCoord));
}
```

10. ФАЙЛОВАЯ СТРУКТУРА

```
/
├── index.html          # Основная игра (5400+ строк)
├── rules.html          # Правила игры
├── situations.html     # Игровые ситуации
├── contacts.html       # Контакты
├── news.html          # Новости
├── sitemap.xml        # Карта сайта
├── robots.txt         # Правила для поисковиков
├── CNAME              # Конфигурация домена
├── .env               # Переменные окружения (Supabase)
├── CLAUDE.md          # Инструкции для Claude Code
├── manual.txt         # Техническое руководство
└── assets/
    ├── teleport.svg   # Иконка телепорта
    ├── arrow.svg      # Иконка стрелки
    ├── jail.svg       # Иконка тюрьмы
    └── temple.svg     # Иконка храма
```

11. ЗАКЛЮЧЕНИЕ

Данное руководство описывает полную реализацию игры Чаупар (Chaupar) на JavaScript/HTML/CSS. Игра представляет собой сложную систему с множественными правилами, специальными механиками и мультиплеерной поддержкой.

Ключевые особенности реализации:
- Единый файл с полной логикой игры
- Отзывчивый дизайн для мобильных устройств
- Real-time мультиплеер через Supabase
- Комплексная система движения с препятствиями
- Специальные поля и механики захвата
- Система дублей и авто-пропуска

Для разработки следует учитывать критические моменты консистентности логики движения, правильного использования фильтрации препятствий и корректной синхронизации состояния в мультиплеере.

ВАЖНО: Данное руководство охватывает все аспекты реализации игры по состоянию на сентябрь 2024 года. При дальнейшей разработке следует обновлять данный документ для поддержания актуальности технической документации.

================================================================================
ЗАКЛЮЧЕНИЕ
================================================================================

Данное техническое руководство описывает полную архитектуру игры Chaupar,
включая все алгоритмы, функции и механики. Код организован модульно с четким
разделением ответственности между компонентами.

Ключевые принципы реализации:
- Простота и читаемость кода
- Отсутствие внешних зависимостей
- Полная адаптивность для разных устройств
- Надежная многопользовательская синхронизация
- Соблюдение традиционных правил игры Chaupar

Архитектура позволяет легко расширять функциональность и добавлять новые
механики без нарушения существующей логики.

Для разработчиков рекомендуется начать изучение с функций:
1. startGame() - точка входа
2. handleGamePlay() - основной цикл
3. performMove() - выполнение ходов
4. calculatePossibleMoves() - расчет ходов

================================================================================